# -*- coding: utf-8 -*-
"""SituacionProblema2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1juMJvvgA0LUkNMBE9_4KTtGW8HVIBwSi

## Situacion Probelma 2
**Rodrigo Lopez Murguia**

**Victor Misael Escalante Alvarado**
"""

import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
import heapq

"""### Declaracion de clases usadas

Declaracion de la clase nodo y arista para represetar las coordenadas y graficarla
"""

class Node :
    def __init__(self, node_id, x, y, is_source):
        self.node_id = node_id
        self.x = x
        self.y = y
        self.is_source = is_source

        self.neighbours = []
        self.distances = []
        self.sector = None
        self.fuente = None
        self.distance_to_source = None
        self.sector = None
        self.color = None
        self.capacity = 0

class Tuberia :
    def __init__(self, start_node, end_node, capacity):
        self.start_node = start_node
        self.end_node = end_node
        self.capacity = float(capacity)

        self.length = 0
        self.open = True

"""### Lectura de Instancias

#### Funcion para reformatear un archivo de texto
Es la preparacion del archivo a partir de los .txt en donde se genera una lista con los nodos , las aristas y la oficina.
"""

def file_prep(route) :
    '''
    num_nodos num_aristas
    [NODES]
    num_nodo x y isfont
    [EDGES]
    num_nodo1 num_nodo2 capacidad
    [OFFICE]
    num_nodo
    [NEW_NODEs]
    x y diametro
    '''
    with open(route) as file:
        # lista de nodos
        nodes = []
        tuberias = []
        new_nodes = []

        lines = file.readlines()

        num_nodos = int(lines[0].split(" ")[0])
        num_aristas = int(lines[0].split(" ")[1])
        # llenamos la lista de nodos
        for i in range(2,2+num_nodos):
            lines[i] = lines[i].split(" ")
            nodes.append(Node(int(lines[i][0]),float(lines[i][1]),float(lines[i][2]),int(lines[i][3])))
        ## llenamos la lista de tuberias
        for i in range(4+num_nodos,4+num_nodos+num_aristas-1):
            lines[i] = lines[i].split(" ")
            tuberias.append(Tuberia(int(lines[i][0]),int(lines[i][1]),float(lines[i][2])))

        # oficina
        office_node = int(lines[4+num_nodos+num_aristas])
        # nuevos nodos

        for i in range(6+num_nodos+num_aristas, len(lines)):
            lines[i] = lines[i].split(" ")

            new_node = Node(-1,float(lines[i][0]),float(lines[i][1]),0)
            new_node.capacity = float(lines[i][2])
            new_nodes.append(new_node)


    return nodes, tuberias , new_nodes, office_node

"""###3. Sectorización de la topología"""

def dijkstra(nodos, aristas, nodoOrigen, fuente):
    distancias = [float('inf')] * max(nodos)
    distancias[nodoOrigen - 1] = 0
    procesado = [False] * max(nodos)
    predecesor = [-1] * max(nodos)
    fila = []
    heapq.heappush(fila, (0, nodoOrigen))
    while fila:
        distanciaActual, nodoActual = heapq.heappop(fila)
        if procesado[nodoActual - 1]:
            continue
        procesado[nodoActual - 1] = True
        for vecino, _ in aristas[nodoActual]:
            distanciaNueva = distanciaActual + distancia_entre_nodos(nodos, nodoActual, vecino)
            if distanciaNueva < distancias[vecino - 1]:
                distancias[vecino - 1] = distanciaNueva
                predecesor[vecino - 1] = nodoActual
                if not procesado[vecino - 1]:
                    heapq.heappush(fila, (distanciaNueva, vecino))
    DistanciaTotal = distancias[fuente - 1]
    return DistanciaTotal if DistanciaTotal != float('inf') else None

def sectorize(nodos, tuberias):
    fuentes = [node for node in nodos if node.is_source == 1]

    # Diccionario predecesores
    node_to_source = {}

    for node in nodos:
        if node.is_source == 1:
            node_to_source[node.node_id] = node.node_id  # Ignorar fuente
        else:
            # Seleccionar la fuente más cercana
            distancias = [
                (fuente.node_id, np.sqrt((node.x - fuente.x)**2 + (node.y - fuente.y)**2))
                for fuente in fuentes
            ]
            fuente_cercana = min(distancias, key=lambda x: x[1])
            node_to_source[node.node_id] = fuente_cercana[0]

    # Identificar las tuberías a cerrar
    tuberias_cerradas = []
    for tuberia in tuberias:
        start_sector = node_to_source[tuberia.start_node]
        end_sector = node_to_source[tuberia.end_node]

        # Si tubería conecta 2 sectores, cerrar
        if start_sector != end_sector:
            tuberias_cerradas.append(tuberia)

    sectores = defaultdict(list)
    for node_id, source_id in node_to_source.items():
        sectores[source_id].append(node_id)


    return sectores, tuberias_cerradas

"""###4. Frescura del Agua"""

#4. Frescura del agua
def frescura_agua(nodos, sectores):
    resultados = []

    for sector, nodos_del_sector in sectores.items():
        # Obtener la fuente del sector
        fuente = next(node for node in nodos if node.node_id == sector)
        nodo_mas_lejano = None
        distancia_maxima = -1

        for nodo_id in nodos_del_sector:
            nodo = next(node for node in nodos if node.node_id == nodo_id)

            # Calcular la distancia de la fuente a este nodo
            distancia = np.sqrt((nodo.x - fuente.x)**2 + (nodo.y - fuente.y)**2)

            # Actualizar el nodo más lejano si encontramos una mayor distancia
            if distancia > distancia_maxima:
                distancia_maxima = distancia
                nodo_mas_lejano = nodo

        # Almacenar el resultado para este sector
        resultados.append({
            "sector": sector,
            "fuente": fuente.node_id,
            "nodo_mas_lejano": nodo_mas_lejano.node_id,
            "distancia": distancia_maxima
        })

    return resultados

"""###5. Flujo maximo de cada sector

**Funciones de apoyo**
"""



"""###6. Muestras de agua"""



"""###7. nuevas conexiones

Funcion para integrar un nodo a la red
"""

def expansion_red(new_nodes, nodos, tuberias):

    for node_nuevo in new_nodes:

        closest_node = min(nodos, key=lambda node: np.sqrt((node.x - node_nuevo.x)**2 + (node.y - node_nuevo.y)**2))

        node_nuevo.is_source = 0

        node_nuevo.neighbours.append(closest_node)
        closest_node.neighbours.append(node_nuevo)

        node_nuevo.distances.append(np.sqrt((node_nuevo.x - closest_node.x)**2 + (node_nuevo.y - closest_node.y)**2))
        closest_node.distances.append(np.sqrt((node_nuevo.x - closest_node.x)**2 + (node_nuevo.y - closest_node.y)**2))

        print(f"\tNuevo nodo en (x,y): ({node_nuevo.x},{node_nuevo.y}) se conecta con {closest_node.node_id} en (x,y) -> ({closest_node.x} , {closest_node.y})")

        nodos.append(node_nuevo)
        tuberias.append(Tuberia(closest_node.node_id, node_nuevo.node_id))

    return nodos, tuberias

"""Funcion para generar un grafico de la red expandida"""

def plot_expanded_graph(ruta,nodos_limpio, tuberias, id_office):
    plt.figure(figsize=(4, 4))
    plt.title(ruta + "(despues de la expansion)")

    node_dict = {node.node_id: node for node in nodos_limpio}

    for node in nodos_limpio:
        if node.is_source == 1:
            plt.plot(node.x, node.y, 'ro', label="Fuente" if "Fuente" not in plt.gca().get_legend_handles_labels()[1] else "")
        elif node.node_id == id_office:
            plt.plot(node.x, node.y, 'mo', label="Oficina Central" if "Oficina Central" not in plt.gca().get_legend_handles_labels()[1] else "")
            plt.text(node.x, node.y, f'Oficina', color='black', fontsize=16)
        else:
            plt.plot(node.x, node.y, f'{Colors[idx]}o', label="Nodos Comunes" if "Nodos Comunes" not in plt.gca().get_legend_handles_labels()[1] else "")

    for tuberia in tuberias_limpio:

        nodo_inicial = node_dict[tuberia.start_node]
        nodo_final = node_dict[tuberia.end_node]

        plt.plot([nodo_inicial.x, nodo_final.x], [nodo_inicial.y, nodo_final.y], 'g', label="Tubería" if "Tubería" not in plt.gca().get_legend_handles_labels()[1] else "")
        plt.text((nodo_inicial.x + nodo_final.x) / 2, (nodo_inicial.y + nodo_final.y) / 2, f'{tuberia.length:.2f}', color='black', fontsize=6)

    plt.legend(loc='upper right')
    plt.grid()
    plt.show()

"""## Algoritmo principal
Toma las instancias , las prepara y corre los algoritmos necesarios para reolver la problemática
"""

user = "colab"

if user == "misa":
    Files_Routes = ["/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/FOS.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/HAN.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/NYT.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/PES.txt"]
elif user == "rocco":
    Files_Routes = ["D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\FOS.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\HAN.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\NYT.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\PES.txt"]
elif user == "colab":
    Files_Routes = ["FOS.txt",
                    "HAN.txt",
                    "NYT.txt",
                    "PES.txt"]

Files_Titles = ["FOS", "HAN", "NYT", "PES"]
Colors = ['b', 'b', 'b', 'b']  # Colores únicos para cada archivo

for idx, route in enumerate(Files_Routes):
    print(f"\n{'='*80}\n\t\t\tProcesando archivo: {Files_Titles[idx]}\n{'='*80}\n")

    nodos_limpio, tuberias_limpio, new_nodes, id_office = file_prep(route)

    # Diccionario de nodos
    node_dict = {node.node_id: node for node in nodos_limpio}

    # Configuración de gráfico
    plt.figure(figsize=(5, 5))
    plt.title(Files_Titles[idx] + "(antes de la expansion)")

    for node in nodos_limpio:
        if node.is_source == 1:
            plt.plot(node.x, node.y, 'ro', label="Fuente" if "Fuente" not in plt.gca().get_legend_handles_labels()[1] else "")
        elif node.node_id == id_office:
            plt.plot(node.x, node.y, 'mo', label="Oficina Central" if "Oficina Central" not in plt.gca().get_legend_handles_labels()[1] else "")
            plt.text(node.x, node.y, f'Oficina', color='black', fontsize=16)
        else:
            plt.plot(node.x, node.y, f'{Colors[idx]}o', label="Nodos Comunes" if "Nodos Comunes" not in plt.gca().get_legend_handles_labels()[1] else "")

    # Dibujar tuberías y mostrar distancia
    for tuberia in tuberias_limpio:
        nodo_inicial = node_dict[tuberia.start_node]
        nodo_final = node_dict[tuberia.end_node]

        tuberia.length = np.sqrt((nodo_inicial.x - nodo_final.x)**2 + (nodo_inicial.y - nodo_final.y)**2)

        nodo_inicial.neighbours.append(nodo_final)
        nodo_inicial.distances.append(tuberia.length)
        nodo_final.neighbours.append(nodo_inicial)
        nodo_final.distances.append(tuberia.length)

        plt.plot([nodo_inicial.x, nodo_final.x], [nodo_inicial.y, nodo_final.y], 'g', label="Tubería" if "Tubería" not in plt.gca().get_legend_handles_labels()[1] else "")
        plt.text((nodo_inicial.x + nodo_final.x) / 2, (nodo_inicial.y + nodo_final.y) / 2, f'{tuberia.length:.2f}', color='black', fontsize=6)

    # Sectorización
    sectores, tuberias_cerradas = sectorize(nodos_limpio, tuberias_limpio)
    print("Sectorización de la topología:\n")
    #print(sectores)
    for sector, nodes in sectores.items():
        print(f"\tSector asociado a la fuente {sector}: Nodos -> {nodes}")

    print("\nTuberías a cerrar:\n")
    for tuberia in tuberias_cerradas:
        print(f"\tTubería entre {tuberia.start_node} y {tuberia.end_node} con capacidad de {tuberia.capacity}")
        tuberia.open = False
        plt.plot([node_dict[tuberia.start_node].x, node_dict[tuberia.end_node].x],
                 [node_dict[tuberia.start_node].y, node_dict[tuberia.end_node].y], 'r--', label="Tuberías Cerradas" if "Tuberías Cerradas" not in plt.gca().get_legend_handles_labels()[1] else "")

    # Frescura del Agua
    results_frescura = frescura_agua(nodos_limpio, sectores)
    print("\nNodos más lejanos de cada sector:\n")
    for resultado in results_frescura:
        print(f"\tSector (nodo fuente): {resultado['sector']}, Fuente: {resultado['fuente']}, "
              f"Nodo más lejano: {resultado['nodo_mas_lejano']}, "
              f"Distancia: {resultado['distancia']:.2f}")

        print(f"\tPosicion: {node_dict[resultado['nodo_mas_lejano']].x, node_dict[resultado['nodo_mas_lejano']].y}")

    print("\nFlujo máximo de cada sector:\n")

    # Flujo maximo
    for sector, nodes in sectores.items():
        print(f"\tSector asociado a la fuente {sector}: Nodos -> {nodes}")
        #max_flow(sector,nodos_limpio,tuberias_limpio)

    plt.legend(loc='upper right')
    plt.grid()
    plt.show()
    # agregando nuevos nodos
    print("\nAgregando nuevos nodos:\n")

    #nodos_limpio, tuberias_limpio = expansion_red(new_nodes, nodos_limpio, tuberias_limpio)

    plot_expanded_graph(Files_Titles[idx], nodos_limpio, tuberias_limpio, id_office)


    # Añadir leyenda