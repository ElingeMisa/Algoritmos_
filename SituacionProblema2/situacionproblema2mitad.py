# -*- coding: utf-8 -*-
"""SituacionProblema2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1juMJvvgA0LUkNMBE9_4KTtGW8HVIBwSi

## Situacion Probelma 2
**Rodrigo Lopez Murguia**

**Victor Misael Escalante Alvarado**
"""

import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
import heapq

"""### Declaracion de clases usadas

Declaracion de la clase nodo y arista para represetar las coordenadas y graficarla
"""

class Node :
    def __init__(self, node_id, x, y, is_source):
        self.node_id = node_id
        self.x = x
        self.y = y
        self.is_source = is_source

        self.neighbours = []
        self.distances = []
        self.sector = None
        self.fuente = None
        self.distance_to_source = None
        self.sector = None
        self.color = None

class Tuberia :
    def __init__(self, start_node, end_node, capacity):
        self.start_node = start_node
        self.end_node = end_node
        self.capacity = float(capacity)

        self.length = 0

"""### Lectura de Instancias

#### Funcion para reformatear un archivo de texto
Es la preparacion del archivo a partir de los .txt en donde se genera una lista con los nodos , las aristas y la oficina.
"""

def file_prep(route) :
    '''
    num_nodos num_aristas
    [NODES]
    num_nodo x y isfont
    [EDGES]
    num_nodo1 num_nodo2 capacidad
    [OFFICE]
    num_nodo
    [NEW_NODEs]
    x y diametro
    '''
    with open(route) as file:
        # lista de nodos
        nodes = []
        tuberias = []
        new_nodes = []

        lines = file.readlines()

        num_nodos = int(lines[0].split(" ")[0])
        num_aristas = int(lines[0].split(" ")[1])
        # llenamos la lista de nodos
        for i in range(2,2+num_nodos):
            lines[i] = lines[i].split(" ")
            nodes.append(Node(int(lines[i][0]),float(lines[i][1]),float(lines[i][2]),int(lines[i][3])))
        ## llenamos la lista de tuberias
        for i in range(4+num_nodos,4+num_nodos+num_aristas-1):
            lines[i] = lines[i].split(" ")
            tuberias.append(Tuberia(int(lines[i][0]),int(lines[i][1]),float(lines[i][2])))

        # oficina
        office_node = int(lines[4+num_nodos+num_aristas])
        # nuevos nodos

        for i in range(6+num_nodos+num_aristas, len(lines)):
            lines[i] = lines[i].split(" ")

            new_node = Node(-1,float(lines[i][0]),float(lines[i][1]),0)
            new_nodes.append(new_node)


    return nodes, tuberias , new_nodes, office_node

"""3. Sectorización de la topología"""

def dijkstra(nodos, aristas, nodoOrigen, fuente):
    distancias = [float('inf')] * max(nodos)
    distancias[nodoOrigen - 1] = 0
    procesado = [False] * max(nodos)
    predecesor = [-1] * max(nodos)
    fila = []
    heapq.heappush(fila, (0, nodoOrigen))
    while fila:
        distanciaActual, nodoActual = heapq.heappop(fila)
        if procesado[nodoActual - 1]:
            continue
        procesado[nodoActual - 1] = True
        for vecino, _ in aristas[nodoActual]:
            distanciaNueva = distanciaActual + distancia_entre_nodos(nodos, nodoActual, vecino)
            if distanciaNueva < distancias[vecino - 1]:
                distancias[vecino - 1] = distanciaNueva
                predecesor[vecino - 1] = nodoActual
                if not procesado[vecino - 1]:
                    heapq.heappush(fila, (distanciaNueva, vecino))
    DistanciaTotal = distancias[fuente - 1]
    return DistanciaTotal if DistanciaTotal != float('inf') else None

def sectorize(nodos, tuberias):
    fuentes = [node for node in nodos if node.is_source == 1]

    # Diccionario predecesores
    node_to_source = {}

    for node in nodos:
        if node.is_source == 1:
            node_to_source[node.node_id] = node.node_id  # Ignorar fuente
        else:
            # Seleccionar la fuente más cercana
            distancias = [
                (fuente.node_id, np.sqrt((node.x - fuente.x)**2 + (node.y - fuente.y)**2))
                for fuente in fuentes
            ]
            fuente_cercana = min(distancias, key=lambda x: x[1])
            node_to_source[node.node_id] = fuente_cercana[0]

    # Identificar las tuberías a cerrar
    tuberias_cerradas = []
    for tuberia in tuberias:
        start_sector = node_to_source[tuberia.start_node]
        end_sector = node_to_source[tuberia.end_node]

        # Si tubería conecta 2 sectores, cerrar
        if start_sector != end_sector:
            tuberias_cerradas.append(tuberia)

    sectores = defaultdict(list)
    for node_id, source_id in node_to_source.items():
        sectores[source_id].append(node_id)


    return sectores, tuberias_cerradas

"""4. Frescura del Agua"""

#4. Frescura del agua
def frescura_agua(nodos, sectores):
    resultados = []

    for sector, nodos_del_sector in sectores.items():
        # Obtener la fuente del sector
        fuente = next(node for node in nodos if node.node_id == sector)
        nodo_mas_lejano = None
        distancia_maxima = -1

        for nodo_id in nodos_del_sector:
            nodo = next(node for node in nodos if node.node_id == nodo_id)

            # Calcular la distancia de la fuente a este nodo
            distancia = np.sqrt((nodo.x - fuente.x)**2 + (nodo.y - fuente.y)**2)

            # Actualizar el nodo más lejano si encontramos una mayor distancia
            if distancia > distancia_maxima:
                distancia_maxima = distancia
                nodo_mas_lejano = nodo

        # Almacenar el resultado para este sector
        resultados.append({
            "sector": sector,
            "fuente": fuente.node_id,
            "nodo_mas_lejano": nodo_mas_lejano.node_id,
            "distancia": distancia_maxima
        })

    return resultados

"""5. Flujo maximo de cada sector"""

def construir_red_residual(nodos, tuberias, sector):
    # Crear un mapeo de nodos a índices consecutivos
    nodo_a_indice = {nodo_id: i for i, nodo_id in enumerate(sector)}
    n = len(sector)
    R = [[0] * n for _ in range(n)]  # Matriz de capacidad residual

    # Agregar capacidades de tuberías entre nodos del sector
    for tuberia in tuberias:
        if tuberia.start_node in sector and tuberia.end_node in sector:
            i = nodo_a_indice[tuberia.start_node]
            j = nodo_a_indice[tuberia.end_node]
            R[i][j] = tuberia.capacity

    return R, nodo_a_indice

# Implementación de Ford-Fulkerson
def ford_fulkerson(R, source_idx, sink_idx):
    n = len(R)
    residual = [row[:] for row in R]
    max_flow = 0

    def bfs():
        visited = [False] * n
        parent = [-1] * n
        queue = [source_idx]
        visited[source_idx] = True

        while queue:
            u = queue.pop(0)
            for v in range(n):
                if not visited[v] and residual[u][v] > 0:
                    parent[v] = u
                    visited[v] = True
                    if v == sink_idx:
                        path = []
                        flow = float('inf')
                        curr = v
                        while curr != source_idx:
                            prev = parent[curr]
                            flow = min(flow, residual[prev][curr])
                            path.append(curr)
                            curr = prev
                        path.append(source_idx)
                        return path[::-1], flow
                    queue.append(v)
        return None, 0

    while True:
        path, flow = bfs()
        if not path:
            break
        for i in range(len(path) - 1):
            u, v = path[i], path[i + 1]
            residual[u][v] -= flow
            residual[v][u] += flow
        max_flow += flow

    return max_flow

def flujo_maximo_por_sector(nodos, tuberias, sectores):
    resultados = []

    for fuente, nodos_sector in sectores.items():
        nodo_mas_lejano = max(
            nodos_sector,
            key=lambda nodo_id: np.sqrt((nodos[nodo_id].x - nodos[fuente].x) ** 2 + (nodos[nodo_id].y - nodos[fuente].y) ** 2)
        )
        R, nodo_a_indice = construir_red_residual(nodos, tuberias, nodos_sector)

        fuente_idx = nodo_a_indice[fuente]
        destino_idx = nodo_a_indice[nodo_mas_lejano]

        max_flow = ford_fulkerson(R, fuente_idx, destino_idx)
        resultados.append({
            "fuente": fuente,
            "flujo_maximo": max_flow,
            "nodo_mas_lejano": nodo_mas_lejano
        })

    return resultados

def calcular_y_reportar_flujo_maximo(nombre_archivo):
    nodos, tuberias, _, oficina = file_prep(nombre_archivo)
    sectores, _ = sectorize(nodos, tuberias)

    resultados = flujo_maximo_por_sector({node.node_id: node for node in nodos}, tuberias, sectores)

    for resultado in resultados:
        print(f"\tSector con fuente en {resultado['fuente']}:\n")
        print(f"\t\tFlujo máximo: {resultado['flujo_maximo']}")
        print(f"\t\tNodo más lejano: {resultado['nodo_mas_lejano']}\n")

"""#### Algoritmo principal
Toma las instancias , las prepara y corre los algoritmos necesarios para reolver la problemática
"""

import matplotlib.pyplot as plt
import numpy as np

user = "colab"

if user == "misa":
    Files_Routes = ["/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/FOS.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/HAN.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/NYT.txt",
                    "/Users/misa_v/Library/CloudStorage/OneDrive-InstitutoTecnologicoydeEstudiosSuperioresdeMonterrey/Sem 5/Algoritmos_/SituacionProblema2/PES.txt"]
elif user == "rocco":
    Files_Routes = ["D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\FOS.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\HAN.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\NYT.txt",
                    "D:\\Tec\\Semestre V\\TC2038 Algoritmos Avanzados\\Code\\SP2\\PES.txt"]
elif user == "colab":
    Files_Routes = ["FOS.txt",
                    "HAN.txt",
                    "NYT.txt",
                    "PES.txt"]

Files_Titles = ["FOS", "HAN", "NYT", "PES"]
Colors = ['b', 'b', 'b', 'b']  # Colores únicos para cada archivo

for idx, route in enumerate(Files_Routes):
    print(f"\n{'='*40}\nProcesando archivo: {Files_Titles[idx]}\n{'='*40}\n")

    nodos_limpio, tuberias_limpio, new_nodes, id_office = file_prep(route)

    # Diccionario de nodos
    node_dict = {node.node_id: node for node in nodos_limpio}

    # Configuración de gráfico
    plt.figure(figsize=(5, 5))
    plt.title(Files_Titles[idx])

    for node in nodos_limpio:
        if node.is_source == 1:
            plt.plot(node.x, node.y, 'ro', label="Fuente" if "Fuente" not in plt.gca().get_legend_handles_labels()[1] else "")
        elif node.node_id == id_office:
            plt.plot(node.x, node.y, 'mo', label="Oficina Central" if "Oficina Central" not in plt.gca().get_legend_handles_labels()[1] else "")
            plt.text(node.x, node.y, f'Oficina', color='black', fontsize=16)
        else:
            plt.plot(node.x, node.y, f'{Colors[idx]}o', label="Nodos Comunes" if "Nodos Comunes" not in plt.gca().get_legend_handles_labels()[1] else "")

    # Dibujar tuberías y mostrar distancia
    for tuberia in tuberias_limpio:
        nodo_inicial = node_dict[tuberia.start_node]
        nodo_final = node_dict[tuberia.end_node]

        tuberia.length = np.sqrt((nodo_inicial.x - nodo_final.x)**2 + (nodo_inicial.y - nodo_final.y)**2)

        nodo_inicial.neighbours.append(nodo_final)
        nodo_inicial.distances.append(tuberia.length)
        nodo_final.neighbours.append(nodo_inicial)
        nodo_final.distances.append(tuberia.length)

        plt.plot([nodo_inicial.x, nodo_final.x], [nodo_inicial.y, nodo_final.y], 'g', label="Tubería" if "Tubería" not in plt.gca().get_legend_handles_labels()[1] else "")
        plt.text((nodo_inicial.x + nodo_final.x) / 2, (nodo_inicial.y + nodo_final.y) / 2, f'{tuberia.length:.2f}', color='black', fontsize=6)

    # Sectorización
    sectores, tuberias_cerradas = sectorize(nodos_limpio, tuberias_limpio)
    print("Sectorización de la topología:\n")
    for sector, nodes in sectores.items():
        print(f"\tSector asociado a la fuente {sector}: Nodos -> {nodes}")

    print("\nTuberías a cerrar:\n")
    for tuberia in tuberias_cerradas:
        print(f"\tTubería entre {tuberia.start_node} y {tuberia.end_node} con capacidad de {tuberia.capacity}")
        plt.plot([node_dict[tuberia.start_node].x, node_dict[tuberia.end_node].x],
                 [node_dict[tuberia.start_node].y, node_dict[tuberia.end_node].y], 'r--', label="Tuberías Cerradas" if "Tuberías Cerradas" not in plt.gca().get_legend_handles_labels()[1] else "")

    # Frescura del Agua
    results_frescura = frescura_agua(nodos_limpio, sectores)
    print("\nNodos más lejanos de cada sector:\n")
    for resultado in results_frescura:
        print(f"\tSector (nodo fuente): {resultado['sector']}, Fuente: {resultado['fuente']}, "
              f"Nodo más lejano: {resultado['nodo_mas_lejano']}, "
              f"Distancia: {resultado['distancia']:.2f}")

        print(f"\tPosicion: {node_dict[resultado['nodo_mas_lejano']].x, node_dict[resultado['nodo_mas_lejano']].y}")

    print("\nFlujo máximo de cada sector:\n")
    calcular_y_reportar_flujo_maximo(route)
    # Añadir leyenda
    plt.legend(loc='upper right')
    plt.grid()
    plt.show()

